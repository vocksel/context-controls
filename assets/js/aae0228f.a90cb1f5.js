"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[939],{66454:function(n){n.exports=JSON.parse('{"functions":[{"name":"new","desc":"Constructs an Action instance from a name. You then need to use the various\\nmethods of this class to setup the callback, input types, and anything else\\nbefore binding.\\n\\n```lua\\nlocal action = Action.new(\\"foo\\")\\n\\naction:setInputTypes({\\n\\tEnum.KeyCode.E,\\n\\tEnum.UserInputType.MouseButton1,\\n})\\n\\naction:setCallback(function(input: InputObject)\\n\\tprint(\\"Hello, world!\\")\\nend)\\n```","params":[{"name":"name","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"Action\\r\\n"}],"function_type":"static","source":{"line":103,"path":"src/Action.lua"}},{"name":"fromObject","desc":"Constructs an Action from a table of properties. This allows you to setup\\neverything, such as the name, callback, and input types, without having to\\ncall any methods.\\n\\nAll of the properties listed above can be used here.\\n\\n```lua\\nlocal action = Action.fromObject({\\n\\tname = \\"foo\\",\\n\\tinputTypes = {\\n\\t\\tEnum.KeyCode.E,\\n\\t\\tEnum.UserInputType.MouseButton1,\\n\\t},\\n\\tcallback = function(input: InputObject)\\n\\t\\tprint(\\"Hello, world!\\")\\n\\tend\\n})\\n```","params":[{"name":"actionObject","desc":"","lua_type":"ActionObject"}],"returns":[{"desc":"","lua_type":"Action\\r\\n"}],"function_type":"static","source":{"line":136,"path":"src/Action.lua"}},{"name":"setCallback","desc":"Sets the callback for the action.\\n\\nThis is what gets called when one of the input types is activated by the user.\\n\\n```lua\\nlocal action = Action.new(\\"foo\\")\\n\\naction:setCallback(function(input: InputObject)\\n\\tprint(\\"Hello world!\\")\\nend)\\n```","params":[{"name":"callback","desc":"","lua_type":"ActionCallback"}],"returns":[],"function_type":"method","source":{"line":161,"path":"src/Action.lua"}},{"name":"setInputTypes","desc":"Sets the input types that the action will be triggered for.\\n\\n```lua\\nlocal action = Action.new(\\"foo\\")\\n\\naction:setInputTypes({\\n\\tEnum.KeyCode.E,\\n\\tEnum.KeyCode.ButtonX,\\n})\\n```","params":[{"name":"inputTypes","desc":"","lua_type":"InputTypes"}],"returns":[],"function_type":"method","source":{"line":177,"path":"src/Action.lua"}},{"name":"bindAtPriority","desc":"Binds the action at the given priority level.\\n\\nFrom here, any of the input types being triggered will cause the callback to\\nbe run.\\n\\nIf the callback or input types are not set, this function will error.\\n\\nIf the function is already bound, it will error.\\n\\n```lua\\nlocal action = Action.new(\\"foo\\")\\naction:setCallback(...)\\naction:setInputTypes(...)\\n\\naction:bindAtPriority(Enum.ContextActionPriority.High.Value)\\n```","params":[{"name":"priority","desc":"","lua_type":"Enum.ContextActionPriority | number"}],"returns":[],"function_type":"method","source":{"line":199,"path":"src/Action.lua"}},{"name":"bind","desc":"Binds the action at the same priority as the `priority` property.\\n\\nFrom here, any of the input types being triggered will cause the callback to\\nbe run.\\n\\nIf the callback or input types are not set, this function will error.\\n\\nIf the function is already bound, it will error.\\n\\n```lua\\nlocal action = Action.new(\\"foo\\")\\naction:setCallback(...)\\naction:setInputTypes(...)\\n\\naction:bind()\\n```","params":[],"returns":[],"function_type":"method","source":{"line":232,"path":"src/Action.lua"}},{"name":"unbind","desc":"Unbinds the action so that the callback will not be run when one of the\\ninput types is triggered.\\n\\n```lua\\nlocal action = Action.new(\\"foo\\")\\naction:setCallback(...)\\naction:setInputTypes(...)\\n\\naction:bind()\\n\\n-- later\\naction:unbind()\\n```","params":[],"returns":[],"function_type":"method","source":{"line":251,"path":"src/Action.lua"}},{"name":"addTrigger","desc":"Automatically binds and unbinds the action when in range of a ProximityPrompt.\\n\\nWith this method, you do not need to call `bind()`, `unbind()`, or\\n`setCallback()`. These methods are all handled automatically based on the\\n`PromptShown` and `PromptHidden` events of the ProximityPrompt.\\n\\n:::caution\\nWhen using this method do not manually bind and unbind the action as this\\ncan lead to the action getting unexpectedly stuck in bound/unbound states.\\n:::\\n\\n```lua\\nlocal action = Action.new(\\"foo\\")\\naction:setInputTypes(...)\\n\\naction:addTrigger(trigger, function(input: InputObject)\\n\\tprint(\\"Hello world!\\")\\nend)\\n```\\n\\nYou can add as many triggers as you want for the same action, and they will\\nall take control of binding and unbinding it.","params":[{"name":"trigger","desc":"","lua_type":"ProximityPrompt"},{"name":"callback","desc":"","lua_type":"() -> nil"}],"returns":[],"function_type":"method","source":{"line":282,"path":"src/Action.lua"}}],"properties":[{"name":"name","desc":"The name of the action.","lua_type":"string","source":{"line":53,"path":"src/Action.lua"}},{"name":"inputTypes","desc":"The various input types that the action responds to.","lua_type":"InputTypes","source":{"line":60,"path":"src/Action.lua"}},{"name":"inputState","desc":"A specific UserInputState that the callback responds to.\\n\\nBy default, the callback is called twice: once when the user starts\\ninteracting, and again when they stop. This is because ContextActionService\\ndoes not use `InputBegan` or `InputEnd` events like UserInputService. It\\ntriggers the callback for both, and leaves it up to the user to filter out\\nthe one they want.\\n\\nInstead of having to check `if input.UserInputState == Enum.UserInputState.Foo`\\nin your callback, you can simply set this property.","lua_type":"Enum.UserInputState","source":{"line":76,"path":"src/Action.lua"}},{"name":"priority","desc":"Sets the priority that ContextActionService will use for the action. By\\ndefault this is `Enum.ContextActionPriority.Default.Value`","lua_type":"number","source":{"line":84,"path":"src/Action.lua"}}],"types":[{"name":"InputTypes","desc":"Valid input types that can be used for an Action.","lua_type":"{ Enum.KeyCode | Enum.UserInputType | Enum.PlayerActions | string }","source":{"line":21,"path":"src/Action.lua"}},{"name":"ActionCallback","desc":"Signature of the callback that will be run when the Action is triggered.","lua_type":"(InputObject) -> nil","source":{"line":28,"path":"src/Action.lua"}},{"name":"ActionObject","desc":"Properties that can be set when constructing an Action from an object.","lua_type":"{ name: string, priority: Enum.ContextActionPriority?, inputState: Enum.UserInputState?, inputTypes: { InputTypes }?, callback: ActionCallback?, }","source":{"line":35,"path":"src/Action.lua"}}],"name":"Action","desc":"This is the class that wraps around ContextActionService to provide a better\\nAPI to work with.\\n\\nYou should typically use `ContextControls.createAction()`, but you can also\\ninstantiate an Action instance manually using `Action.new()` or\\n`Action.fromObject()` which are documented below.","source":{"line":13,"path":"src/Action.lua"}}')}}]);