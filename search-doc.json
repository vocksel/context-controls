[{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Getting Started","url":"docs/intro#installation","content":"Installing the package is quick and easy whether you use a package manager like Wally or work directly in Studio. "},{"title":"Wally (Recommended)​","type":1,"pageTitle":"Getting Started","url":"docs/intro#wally-recommended","content":"Add the following to your wally.toml and run wally install to download the package. [dependencies] ContextControls = &quot;vocksel/context-controls@1.0.0&quot; Copy Make sure the resulting Packages folder is synced into your experience using a tool like Rojo. "},{"title":"Roblox Studio​","type":1,"pageTitle":"Getting Started","url":"docs/intro#roblox-studio","content":"Download a copy of the rbxm from the releases page under the Assets section.Drag and drop the file into Roblox Studio to add it to your experience. "},{"title":"Next Steps​","type":1,"pageTitle":"Getting Started","url":"docs/intro#next-steps","content":"Check out the API reference for everything that the package exposes. "},{"title":"Contributing","type":0,"sectionRef":"#","url":"docs/contributing","content":"","keywords":""},{"title":"Getting Started​","type":1,"pageTitle":"Contributing","url":"docs/contributing#getting-started","content":""},{"title":"VS Code​","type":1,"pageTitle":"Contributing","url":"docs/contributing#vs-code","content":"You should be using Visual Studio Code as your text editor and have the following extensions installed: RojoSeleneStyLua Once installed, the Rojo extension will display a welcome screen. Scroll down to the section for the Roblox Studio plugin and select &quot;Manage it for me.&quot; Next time you open a place in Studio you will have the Rojo plugin ready to go. "},{"title":"Foreman​","type":1,"pageTitle":"Contributing","url":"docs/contributing#foreman","content":"Foreman handles the installation of several of our other tools, like Rojo, Wally, Selene, and StyLua. To install through Cargo, run the following: cargo install foreman Copy note The cargo command is a part of Rust. If you don't wish to install Rust on your device you can get the latest Foreman binary from the releases page. To make the tools that Foreman installs avialable on your system you will also need to manually add its bin folder to your PATH: Windows Add C:\\Users\\You\\.foreman\\bin to your PATHFollow this guide for how to do that MacOS Open TerminalOpen the corresponding file for your terminal Bash: nano ~/.bash_profileZSH: nano ~/.zshrc Append export PATH=&quot;$PATH:~/.foreman/bin to the end of the file tip Changes to the PATH will only take effect in new terminals. If you are not able to invoke the tools that Foreman manages, try closing and reopening your terminal. "},{"title":"Development​","type":1,"pageTitle":"Contributing","url":"docs/contributing#development","content":"With the above requirements satisfied, run the following commands from your clone of this repository to start developing: # Install Rojo, Wally, Selene, StyLua, and others foreman install # Install this package's dependencie wally install # Serve the project rojo serve dev.project.json Copy Now you can open Studio to a new Baseplate and start syncing with the Rojo plugin. "},{"title":"Testing​","type":1,"pageTitle":"Contributing","url":"docs/contributing#testing","content":"While developing, you should also be writing unit tests. Unit tests are written in .spec.lua files. You can see examples of this throughout the repository's codebase. To run tests, simply start the experience in Studio. You will see in the output if tests are passing or failing. If your code is not properly tested, maintainers will let you know and offer suggestions on how to improve your tests so you can get your pull request merged. "},{"title":"ContextControls","type":0,"sectionRef":"#","url":"api/ContextControls","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ContextControls","url":"api/ContextControls#functions","content":" "},{"title":"createAction​","type":1,"pageTitle":"ContextControls","url":"api/ContextControls#createAction","content":"&lt;/&gt; ContextControls.createAction(actionObject: Action.ActionObject) → Action Constructs an Action from a table of properties. This allows you to setup everything, such as the name, callback, and input types, without having to call any methods. local action = Action.fromObject({ name = &quot;foo&quot;, inputTypes = { Enum.KeyCode.E, Enum.UserInputType.MouseButton1, }, callback = function(input: InputObject) print(&quot;Hello, world!&quot;) end })   "},{"title":"getJumpButton​","type":1,"pageTitle":"ContextControls","url":"api/ContextControls#getJumpButton","content":"This item only works when running on the client. Client This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; ContextControls.getJumpButton() → GuiObject?  Returns the LocalPlayer's JumpButton if they are on a touch enabled device, nil otherwise. local jumpButton = ContextControls.getJumpButton() print(jumpButton:GetFullName()) -- ...TouchGui.TouchControlFrame.JumpButton   "},{"title":"getTouchGui​","type":1,"pageTitle":"ContextControls","url":"api/ContextControls#getTouchGui","content":"This item only works when running on the client. Client This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; ContextControls.getTouchGui() → GuiObject?  Returns the LocalPlayer's TouchGui if they are on a touch enabled device, nil otherwise. local touchGui = ContextControls.getTouchGui() print(touchGui:GetFullName()) -- Players.Player1.PlayerGui.TouchGui  "},{"title":"Action","type":0,"sectionRef":"#","url":"api/Action","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Action","url":"api/Action#types","content":" "},{"title":"InputTypes​","type":1,"pageTitle":"Action","url":"api/Action#InputTypes","content":"&lt;/&gt; type InputTypes = {Enum.KeyCode | Enum.UserInputType | Enum.PlayerActions | string} Valid input types that can be used for an Action.  "},{"title":"ActionCallback​","type":1,"pageTitle":"Action","url":"api/Action#ActionCallback","content":"&lt;/&gt; type ActionCallback = (InputObject ) → nil Signature of the callback that will be run when the Action is triggered.  "},{"title":"ActionObject​","type":1,"pageTitle":"Action","url":"api/Action#ActionObject","content":"&lt;/&gt; type ActionObject = { name: string, priority: Enum.ContextActionPriority?, inputState: Enum.UserInputState?, inputTypes: {InputTypes}?, callback: ActionCallback?, } Properties that can be set when constructing an Action from an object. "},{"title":"Properties​","type":1,"pageTitle":"Action","url":"api/Action#properties","content":" "},{"title":"name​","type":1,"pageTitle":"Action","url":"api/Action#name","content":"&lt;/&gt; Action.name: string The name of the action.  "},{"title":"inputTypes​","type":1,"pageTitle":"Action","url":"api/Action#inputTypes","content":"&lt;/&gt; Action.inputTypes: InputTypes The various input types that the action responds to.  "},{"title":"inputState​","type":1,"pageTitle":"Action","url":"api/Action#inputState","content":"&lt;/&gt; Action.inputState: Enum.UserInputState A specific UserInputState that the callback responds to. By default, the callback is called twice: once when the user starts interacting, and again when they stop. This is because ContextActionService does not use InputBegan or InputEnd events like UserInputService. It triggers the callback for both, and leaves it up to the user to filter out the one they want. Instead of having to check if input.UserInputState == Enum.UserInputState.Foo in your callback, you can simply set this property.  "},{"title":"priority​","type":1,"pageTitle":"Action","url":"api/Action#priority","content":"&lt;/&gt; Action.priority: number Sets the priority that ContextActionService will use for the action. By default this is Enum.ContextActionPriority.Default.Value "},{"title":"Functions​","type":1,"pageTitle":"Action","url":"api/Action#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Action","url":"api/Action#new","content":"&lt;/&gt; Action.new(name: string) → Action Constructs an Action instance from a name. You then need to use the various methods of this class to setup the callback, input types, and anything else before binding. local action = Action.new(&quot;foo&quot;) action:setInputTypes({ Enum.KeyCode.E, Enum.UserInputType.MouseButton1, }) action:setCallback(function(input: InputObject) print(&quot;Hello, world!&quot;) end)   "},{"title":"fromObject​","type":1,"pageTitle":"Action","url":"api/Action#fromObject","content":"&lt;/&gt; Action.fromObject(actionObject: ActionObject) → Action Constructs an Action from a table of properties. This allows you to setup everything, such as the name, callback, and input types, without having to call any methods. All of the properties listed above can be used here. local action = Action.fromObject({ name = &quot;foo&quot;, inputTypes = { Enum.KeyCode.E, Enum.UserInputType.MouseButton1, }, callback = function(input: InputObject) print(&quot;Hello, world!&quot;) end })   "},{"title":"setCallback​","type":1,"pageTitle":"Action","url":"api/Action#setCallback","content":"&lt;/&gt; Action:setCallback(callback: ActionCallback) → () Sets the callback for the action. This is what gets called when one of the input types is activated by the user. local action = Action.new(&quot;foo&quot;) action:setCallback(function(input: InputObject) print(&quot;Hello world!&quot;) end)   "},{"title":"setInputTypes​","type":1,"pageTitle":"Action","url":"api/Action#setInputTypes","content":"&lt;/&gt; Action:setInputTypes(inputTypes: InputTypes) → () Sets the input types that the action will be triggered for. local action = Action.new(&quot;foo&quot;) action:setInputTypes({ Enum.KeyCode.E, Enum.KeyCode.ButtonX, })   "},{"title":"bindAtPriority​","type":1,"pageTitle":"Action","url":"api/Action#bindAtPriority","content":"&lt;/&gt; Action:bindAtPriority(priority: Enum.ContextActionPriority | number) → () Binds the action at the given priority level. From here, any of the input types being triggered will cause the callback to be run. If the callback or input types are not set, this function will error. If the function is already bound, it will error. local action = Action.new(&quot;foo&quot;) action:setCallback(...) action:setInputTypes(...) action:bindAtPriority(Enum.ContextActionPriority.High.Value)   "},{"title":"bind​","type":1,"pageTitle":"Action","url":"api/Action#bind","content":"&lt;/&gt; Action:bind() → () Binds the action at the same priority as the priority property. From here, any of the input types being triggered will cause the callback to be run. If the callback or input types are not set, this function will error. If the function is already bound, it will error. local action = Action.new(&quot;foo&quot;) action:setCallback(...) action:setInputTypes(...) action:bind()   "},{"title":"unbind​","type":1,"pageTitle":"Action","url":"api/Action#unbind","content":"&lt;/&gt; Action:unbind() → () Unbinds the action so that the callback will not be run when one of the input types is triggered. local action = Action.new(&quot;foo&quot;) action:setCallback(...) action:setInputTypes(...) action:bind() -- later action:unbind()   "},{"title":"addTrigger​","type":1,"pageTitle":"Action","url":"api/Action#addTrigger","content":"&lt;/&gt; Action:addTrigger( trigger: ProximityPrompt , callback: () → nil ) → () Automatically binds and unbinds the action when in range of a ProximityPrompt. With this method, you do not need to call bind(), unbind(), or setCallback(). These methods are all handled automatically based on the PromptShown and PromptHidden events of the ProximityPrompt. caution When using this method do not manually bind and unbind the action as this can lead to the action getting unexpectedly stuck in bound/unbound states. local action = Action.new(&quot;foo&quot;) action:setInputTypes(...) action:addTrigger(trigger, function(input: InputObject) print(&quot;Hello world!&quot;) end) You can add as many triggers as you want for the same action, and they will all take control of binding and unbinding it. "}]